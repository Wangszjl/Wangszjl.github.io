[{"title":"04-有限元理论推导（二）","url":"/2024/09/05/有限元理论推导（二）/","content":"# 2 一维有限元方法\n\n## 2.1 背景\n本部分以加权残差法的Galerkin形式为基础介绍有限元方法。有限元方法的第一步是将感兴趣的区域分割成包含节点的子区域，或单元，并在每个单元上定义要使用的“形状”类型。一个二阶单元有三个节点，它被优化地放置在单元的中点；一个三阶单元由四个节点组成，最好在单元的三分之一间隔处放置。单元和节点的集合称为“有限元网格”。在程序中使用的形状函数的类型直接与选择的网格类型相关。\n\n## 2.2 形状函数\n在第一篇文章中，我们使用分段多项式形状函数$f_i(x)$来处理一维（1-D）热传导问题。现在，我们将正式定义分段多项式插值的过程，并展示对特定的单元使用每个单元的局部函数更方便。\n\n### 2.2.1 线性单元\n让我们从定义一个网格开始，在$0 \\leq x \\leq L$的范围内，单元不一定是等大小的。然后我们在每个单元上定义线性形状函数，如图1所示。\n<br><center>![图1 分段线性单元的形状函数](1.png)</center>\n\n这将是全局有限元网格和形状函数的表示，它允许我们描述我们问题的几何形状。如果网格由$n$个单元组成，它将有$n+1$个节点，其坐标为$x_1, x_2, \\cdots, x_\\{n+1\\}$。单元域由下式给出：\n$$\ne_i = \\{x | x_{i-1} \\leq x \\leq x_{i+1}\\}\n\\tag{2.1}$$\n\n与每个节点相关联的形状函数将被记为$N_i(x)$，并且满足$N_i(x_i) = 1$，$N_j(x_i) = 0$（对于所有$j \\neq i$），由下式给出：\n\n$$\nN_1(x) = \\begin{cases}\n\\frac{x_2-x}{h_1} & \\text{if } x \\in [x_1, x_2] \\\\\n0 & \\text{otherwise}\n\\end{cases}\\tag{2.2}\n$$\n$$\nN_i(x) = \\begin{cases}\n\\frac{x-x_{i-1}}{h_{i-1}} & \\text{if } x \\in [x_{i-1}, x_i] \\\\\n\\frac{x_{i+1}-x}{h_i} & \\text{if } x \\in [x_i, x_{i+1}]\\\\\n0 & \\text{otherwise}\n\\end{cases}\\tag{2.3}\n$$\n$$\nN_{n+1}(x) = \\begin{cases}\n\\frac{x-x_n}{h_n} & \\text{if } x \\in [x_n, x_{n+1}]\\\\\n0 & \\text{otherwise}\n\\end{cases}\\tag{2.4}\n$$\n\n其中$h_i = x_{i+1} - x_{i-1}$，对于$i = 1, 2, \\ldots, n$。\n我们现在定义$T(x)$如下：\n$$T(x)=N_1(x)T_1+N_2(x)T_2+\\cdots+N_{n+1}(x)T_{n+1}\\\\\n=\\sum^{n+1}_{i=1}N_i(x)T_i\\tag{2.5}$$\n式中$T_i$表示节点$i$，即位置$x_i$处的$T$值；$T(x)$为两个节点间的线性函数。我们考虑仅有一个单元的网格，也就是$n=1$。如果$T(x)$在两个节点之间为线性，其形式将为$T(x)=\\alpha_1+\\alpha_2x$。同时$T(x_1)=T_1$，$T(x_2)=T_2$，由此\n$$T_1=\\alpha_1+\\alpha_2x_1\\tag{2.6}\n$$\n$$T_2=\\alpha_1+\\alpha_2x_2\\tag{2.7}\n$$\n求解$\\alpha_1$和$\\alpha_2$，\n$$\\alpha_1=\\frac{T_1x_2-T_2x_1}{h_1}\\tag{2.8}\n$$\n$$\\alpha_2=\\frac{T_2-T_1}{h_1}\\tag{2.9}\n$$\n因此\n$$T(x)=\\frac{T_1x_2-T_2x_1}{h_1}+\\frac{T_2-T_1}{h_1}x\\tag{2.10}$$\n整理得到\n$$T(x)=\\Big [\\frac{x_2-x}{h_1}\\Big]T_1+\\Big [\\frac{x-x_1}{h_1}\\Big]T_2\\tag{2.11}$$\n这与方程2.5的表达式相同，其中$n = 1$。在实践中，与所考虑的特定单元相关的局部坐标系统中的每个单元进行工作将非常方便。如果我们在局部坐标系统中需要描述一个长度为$h^e$的单元，我们将使用以下形式：\n$$T^{(e)}(x)=N^{(e)}_1(x)T^{(e)}_1+N^{(e)}_2(x)T^{(e)}_2\\tag{2.12}$$\n\n式中的$(e)$表示的一个单元，\n$$N^{(e)}_1(x)=\\Big [1-\\frac{x}{h^{(e)}}\\Big ]\\tag{2.13}$$\n$$N^{(e)}_2(x)=\\frac{x}{h^{(e)}\\tag{2.14}}$$\n如图2所示，有\n$$\\frac{dT^{(e)}}{dx}=\\Bigg[\n    \\begin{matrix}\n    \\frac{dN^{(e)}_1}{dx}&\\frac{dN^{(e)}_2}{dx}\\Bigg]\n    \\end{matrix}\n    \\Bigg[\n        \\begin{matrix}T^{(e)}_1\\\\T^{(e)}_2\n        \\end{matrix}\\Bigg]=\\Bigg[\n    \\begin{matrix}\n    -\\frac{1}{h^{(e)}}&\\frac{1}{h^{(e)}}\\Bigg]\n    \\end{matrix}\n    \\Bigg[\n        \\begin{matrix}T^{(e)}_1\\\\T^{(e)}_2\n        \\end{matrix}\\Bigg]\n    $$\n<br><center>![图2 局部节点编号，温度表示，局部形状函数](2.png)</center>\n我们同样需要局部节点和全局节点直接按的关系，如图3所示。但是在我们深入求解之前，我们将介绍一些高阶单元。\n<br><center>![图3 局部节点与全局节点间的映射关系](3.png)</center>\n\n### 2.2.2 二次单元\n从插值函数的角度来看，我们可以从图3.4中看到，如果我们在每个单元上使用抛物线弧而不是线性段，我们可以做得更好。在每个单元上，函数$T(x)$将是二次的，因此形式为：\n\n$$\nT(x) = a_1 + a_2x + a_3x^2\n$$\n\n其中我们需要三个参数来确定；因此，仅仅要求在单元的两端插值是不够的。为了得到第三个关系，我们在单元的中间引入了另一个节点，并且我们还要求在该节点处插值函数。\n\n### 2.2.3 三次单元\n我们可以继续提高近似的阶数。在这种情况下，我们使用三次函数。在这种情况下，我们需要四个节点。对于最佳的近似属性，这些节点最好位于$x = 0, h/3, 2h/3, h$的位置。按照与线性和二次单元相同的过程，我们可以找到形状函数。\n\n## 2.3 稳态传导方程\n### 2.3.1 Galerkin表述\n考虑在区间$0 \\leq x \\leq L$上找到温度分布$T = T(x)$的问题，它满足具有内部热源的稳态1-D方程：\n\n$$\n\\frac{d}{dx}\\left(K \\frac{dT}{dx}\\right) = Q\n$$\n\n其中$x$是长度坐标，$K$是材料的热导率（假设为常数），$Q$是单位体积的内部热生成。\n\n### 2.3.2 可变传导和边界对流\n我们现在将有限元算法扩展到解决薄杆上的稳态温度分布问题，该杆的左端受到对流热负荷，$x = 0$，右端保持固定温度$T_L$，$x = L$。我们还假设没有内部热源（即$Q = 0$），但杆的热导率随$x$变化（由于材料组成的变化或杆的横截面变化），即$K = K(x)$。描述这个问题的微分方程是：\n\n$$\n\\frac{d}{dx}\\left(K(x) \\frac{dT}{dx}\\right) = 0\n$$\n继续将第三章的内容翻译成中文，并使用Markdown格式：\n\n## 2.4 轴对称热传导\n许多涉及流体在管道中流动的稳态热传导问题都涉及到轴对称形式。为了开发相应的有限元算法，方程3.59至3.61的轴对称形式是：\n\n$$\n\\frac{1}{r}\\frac{d}{dr}\\left(r\\frac{dT}{dr}\\right) = Q\n$$\n\n加上边界条件：\n\n$$\n-\\frac{dT}{dr} + h(T - T_{\\infty}) = 0 \\quad \\text{at } r = r_1\n$$\n\n和\n\n$$\nT = T_L \\quad \\text{at } r = r_2\n$$\n\n其中 $r_1$ 和 $r_2$ 分别是内半径和外半径，$T_{\\infty}$ 是外部参考温度，$h$ 是对流换热系数。\n\n## 2.5 自然坐标系统\n我们现在引入一个自然坐标系统来指定单元上的局部操作。我们将单元定义在区间 $-1 \\leq \\xi \\leq 1$，并与变换形式相结合：\n\n$$\nx = x_i + h(\\xi + 1) + \\frac{1}{2}h(\\xi^2 - 1)\n$$\n\n这种坐标系统允许我们通过变换（3.65）轻松地数值评估积分和形状函数的导数，如果我们注意到：\n\n$$\n\\frac{d\\xi}{dx} = \\frac{1}{h}\\frac{d\\xi}{d\\xi} = \\frac{2}{h}\n$$\n\n并且\n\n$$\n\\frac{dx}{d\\xi} = h\n$$\n\n## 2.6 随时间变化的扩散方程\n我们现在将有限元算法扩展到非稳态热扩散方程。假设 $Q = 0$，即没有源或汇。热传导的控制方程通常写为：\n\n$$\n\\frac{\\partial T}{\\partial t} = a \\nabla^2 T\n$$\n\n其中 $\\alpha = k/(\\rho c_p)$ 是热扩散率，$\\rho$ 是密度，$c_p$ 是材料的比热容。\n\n## 2.7 矩阵表述\n有限元方法基于在特定节点处对依赖变量的数值近似；产生了一组必须直接或迭代求解的线性代数方程。对于前面讨论的示例问题，未知数（和因此方程）的数量很少，可以手工容易地解决。然而，对于大多数问题，节点的数量（和因此未知数）将变得更大，需要计算机来执行求解。我们之前使用的系数矩阵是从每个单元上局部评估的，并组装成全局数组。简而言之，局部单元矩阵“填充”到一个大矩阵中，该矩阵包含所有局部单元的贡献。\n\n## 2.8 解决方法\n在所有前面的部分中，将有限元方法应用于控制方程导致了一组线性方程，包括与原始微分方程的各种术语相关的矩阵，如方程3.114。我们可以进一步将这种方程表示为：\n\n$$\nA\\phi = B\n$$\n\n其中\n\n$$\nA = M + \\theta \\Delta t K\n$$\n\n$$\n\\phi = T^{n+1}\n$$\n\n$$\nB = M\\phi^n + (\\theta \\Delta t) K \\phi^n + \\Delta t Q\n$$\n\n所有出现在 $A$ 和 $B$ 中的术语都是已知的，所以我们可以直接求解未知值 $\\phi$。然而，如前所述，求解大型方程组可能会变得非常耗时和昂贵，即使使用大型计算机也是如此，更不用说使用个人计算机了。这种情况引入了特殊方法来求解大型线性方程组的需求。数值线性代数领域就是处理这些方法的数学学科，有些背景的读者可能会通过名字认出高斯消元法、雅可比和高斯-塞德尔迭代法、LU分解、逐次超松弛法、共轭梯度法等方法。开发数值线性代数中的矩阵求解技术是一个领域；我们的目的只是让读者熟悉基本概念，以便理解它们在计算机程序中的实现。方程3.116的解通过对两边乘以 $A^{-1}$ 获得：\n\n$$\n\\phi = A^{-1}B\n$$\n\n如果 $A$ 是大型的，执行这个操作会很困难。幸运的是，存在有效的数值方法，它们允许我们在不需要找到 $A^{-1}$ 的情况下找到 $\\phi$。矩阵代数，包括找到矩阵的逆，将在附录A中更详细地讨论。\n## 2.9 结论\n\n本章的目的是说明和建立有限元方法在一维问题中的应用。从简单的稳态扩散方程开始，逐步过渡到更复杂的方程，最终涵盖了在工程和科学问题中常见的一维时间依赖扩散传输方程。通过对不同程度形状函数的示例问题的推导和使用，我们看到了一个通用的有限元过程的演变，该过程可以应用于广泛的工程问题。通过对整个一组单元或网格的组合，展示了如何产生一组全局矩阵。将全局矩阵系统简化为简单的线性（矩阵）方程形式 $(A\\phi = B)$，其中 $\\phi$ 是包含未知变量的列向量，允许使用标准的矩阵求解程序来求解$\\phi$。在接下来的章节中，我们将扩展算法到二维问题。\n\n在本章结束时，读者应该开始对有限元方法的数学基础有所理解，这些基础来自于这些简单的一维示例。对于那些对有限元方法不太熟悉的读者，我们建议此时再次回顾这些最后几节内容，然后再继续阅读本书剩余的更高级材料。在第4章中，我们将扩展算法到二维问题。\n","categories":["FEM"]},{"title":"03-有限元理论推导（一）","url":"/2024/08/31/有限元理论推导（一）/","content":"\n# 1 加权残差法和伽辽金近似\n## 1.1 经典问题引入\n考虑确定一根长度为$L$、横截面恒定的细长均质金属丝的热传导情况。假定左端暴露在规定的热通量$q$下，右端保持恒温$T=T_L$，并且棒的长度方向被绝缘材料包围。利用傅立叶定律，我们可以写出控制整个棒的温度分布的导线方程，即：\n$$-K\\frac{d^2T}{dx^2}=Q，0<x<L\\tag{1.1}$$\n式中\n    <br>$x$为长度坐标\n    <br>$K$是材料的热传导率（假定为常数）\n    <br>$Q$是单位体积产生的热量\n与这一问题相应的边界条件是\n$$-K\\frac{dT}{dx}=q，x=0\\tag{1.2}$$\n$$T=T_L，x=L\\tag{1.3}$$\n当$q>0$时，热量流向$x=0$处的棒体，这就是公式(1.2)中负号的原因。\n\n假定$Q$是可积的，那么方程(1.1)的解与边界条件(1.2)和(1.3)可以通过直接积分求得：\n$$T(x)=T_L+\\frac{q}{K}(L-x)+\\frac{1}{K}\\int^L_x(\\int^x_0Q(z)dz)dy\\tag{1.4}$$\n如果Q为常数，公式(2.4)简化为：\n$$T(x)=T_L+\\frac{q}{K}(L-x)+\\frac{Q}{2K}(L^2-x^2)\\tag{1.5}$$\n\n## 1.2 弱形式描述\n通常有两种方法可以用有限元来计算和求解方程(1.1)的形式,这两种方法分别称为***Rayleigh-Ritz法***和***Galerkin法***。其他较少使用的方法是基于配位、常数加权和最小平方技术。所有这些程序都是加权残差法的子集。\n<br>无论我们使用哪种方法，第一步都是在$0\\le x \\le L$的区间内划分出网格，网格由一定数量的非重叠子区间组成，覆盖整个域，每个子区间称为一个 \"单元\"。我们用$e_k$表示每个单元，即$e_k=\\{x:x_k\\le x\\le x_{k+1}\\}$。每个子区间的端点$x_k$称为节点。\n温度分布由每个子区间的预设函数（用$\\phi_j(x)$表示）和相应的未知参数$a_j$计算得到。\n<br>因此，我们将一个单元定义为一个子区间$e_k$，以及一组预先确定的函数$\\varphi_j$和相同数量的参数$a_j$。这样如果参数$a_j$已知，则温度长边的近似值$T(x)$也是已知的。在整个域$0 \\le x \\le L$上，我们可以写出\n$$T(x)\\cong a_1\\phi_1(x)+a_2\\phi_2(x)+\\cdots+a_{n+1}\\phi_{n+1}(x)\\tag{1.6}\n$$\n函数$\\phi(x)$称作形状函数，我们将式（1.6）写成求和的形式，即\n$$T(x)=\\sum^{n+1}_{i=1}a_i\\phi_i(x)\\tag{1.7}\n$$\n当使用 (1.7) 形式的表达式近似求解问题时,一般来说，我们无法得到这个偏微分方程的真实解。因此，如果我们将近似解替换为方程（1.1）的左侧，我们得到的将不是同一值，而是与误差相关的某个 \"残差 \"函数。我们将这个残余误差定义为\n$$R(T,x)\\equiv-K\\frac{d^2T}{dx^2}-Q\\tag{1.8}$$\n这里，$T$是真实解$T^*$的近似解，即$R(T^*,x)\\equiv 0$。然而，对任意的$T\\neq T^*$，我们不能令残差在每个$x$点都消失。加权残差法的原理是，我们可以将残差乘以加权函数，令加权残差的积分在每一点$x$上变为0，即\n$$\\int^L_0W(x)R(T,x)dx=0\\tag{1.9}$$\n式中$W(x)$为权重函数。通过选择不同的权重函数并将其替换到弱形式（1.9）中，我们可以生成一个关于未知参数$a_j$线性方程组，该方程组用于确定偏微分方程近似解$T$的形式，该近似解类似于方程（1.7）给出的有限级数。这种方法满足偏微分方程的“平均”或“积分”意义上的解。所选加权函数的类型取决于所选加权残差函数的类型。在Galerkin方法中，权重与形状函数$\\phi(x)$相等，即$W_i(x)=\\phi_i(x)$。\n<br>由于未知参数$a_j$的数量等于形状函数$\\phi_j$的数量，将生成一个方程数量与未知数数量相同的线性代数方程组。如果与偏微分方程相关的边界条件被正确设定和施加，那么这样的方程组的存在性和唯一性是保证的。这种方法在处理高维不规则几何和非线性问题中特别有优势，并且会自动生成一个方程数量与未知数数量相同的方程组。形状函数$\\phi(x)$的定义是有限元方法的关键所在。我们将几乎完全局限于使用简单（线性、二次和三次）插值；可以使用更高阶（和超越）近似，但这会带来额外的复杂性、计算时间和存储要求。使用基本线性、二次函数将证实有限元概念既优雅又极其强大。\n<br>我们现在希望使用我们提出的形状函数$\\phi(x)$作为权重函数$W(x)$来评估方程（1.9）的左端积分。因此，根据伽辽金方法得到：\n$$\\int^L_0\\phi(x)\\Big [-K\\frac{d^2T}{dx^2}-Q\\Big ]dx=0\\tag{1.10}$$\n我们需要找到方程（1.7）中函数$\\phi(x)$的适当形式。由于温度分布必须是$x$的连续函数，最简单的方法是在每个单元上使用分段多项式插值来近似它；特别是，分段线性近似提供了最简单的连续函数近似。不幸的是，这样的函数的一阶导数在单元节点处不连续，因此，在这些地方不存在二阶导数；此外，$T$的二阶导数在每个单元内部将消失。然而，要求二阶导数在所有地方都存在是过于严格的。这将阻止我们处理许多非常有兴趣的物理情况，例如在杆中存在一个单位强度的热源。在这种情况下，方程（1.1）变为\n$$-K\\frac{d^2T}{dx^2}=\\delta(x-x_s)\\tag{1.11}$$\n式中$\\delta$为Delta函数，在$x=x_s$外的各点为0，且在这一点处的值不确定。显然，在$x=x_s$处$T$的二阶导数不存在；方程（1.11）的解为：\n$$T(x)=\n\\begin{cases}\n-\\frac{1}{K}[q(x-L)+(x_s-L)]+T_L&0\\le x\\le x_s\\\\\n-\\frac{1}{K}q(x-L)(x-L)+T_L&x_s\\le x\\le L\n\\end{cases}\\tag{1.12}\n$$\n对方程（1.10）应用分布积分，得到\n$$\\int^L_0\\phi(x)[-K\\frac{d^2 T}{dx^2}]dx=\\int^L_0K\\frac{d\\phi}{dx}\\frac{dT}{dx}dx-K\\phi\\frac{dT}{dx}\\Big |^L_0\\tag{1.13}\n$$\n于是方程（1.10）可重写为\n$$\\int^L_0K\\frac{d\\phi}{dx}\\frac{dT}{dx}dx-\\int^L_0\\phi Qdx-K\\phi\\frac{dT}{dx}\\Big |^L_0=0\\tag{1.14}\n$$\n这仅仅是一个“弱”形式的问题，因为它只包含解$T(x)$的一阶导数，而方程（1.10）包含二阶导数。对函数$T(x)$的微分要求已经减弱，因此得名“弱形式”。请注意，到目前为止还没有进行任何近似，也就是说，在表述中没有丢失任何东西，另一方面，简单的分段线性近似现在变得合理。\n### 例 1\n> 考虑方程（2.1），使用边界条件$T(0)=T_0$以及对流边界条件$-K\\frac{dT}{dx}\\Big |_{x=L}=h(T-T_\\infty)$。式中$h$为热对流传导常数，$T_\\infty$为参考温度。\n加权残差公式（式（1.9）），对于这个问题保持不变，因为它由式（1.1）推导而来，与给定的边界条件无关。每当在边界点给出温度时，我们将在该点的热流项设为零，通过要求权重函数在该点消失来实现。在这种情况下，令$\\phi(0) = 0$，并使用其他边界项中的对流边界条件，方程（1.9）的形式变为\n$$\\int^L_0K\\frac{d\\phi}{dx}\\frac{dT}{dx}-\\int^L_0\\phi Qdx+\\phi(L)h(T_L-T_\\infty)=0\\tag{1.15}$$\n>即加权残差公式。稍后，我们将进一步要求加权函数在边界点处等于1。在这种情况下，$\\phi(L) = 1$，因此加权函数永远不会明确出现在边界项中。\n\n对每个权重函数$\\phi(x)$使用公式（1.7），可将方程（1.14）改写为\n$$\\sum^{n+1}_{j=1}K\\Big [\\int^L_0\\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx}dx\\Big ]a_j-\\int^L_0\\phi_iQdx+\\phi_i\\Big[-K\\frac{dT}{dx}\\Big]\\Big |^{x=L}_{x=0}=0\\\\\ni=1,2,\\cdots,n+1\\tag{1.16}\n$$\n一旦形状函数$\\phi_i$选择好后，可以计算上式的积分。弱形式的伽辽金描述的优势在于，只有有限数量的参数$a_i$需要确定，$i = 1, \\cdots, n + 1$，这与方程(1.1)或(1.9)中需要确定$0 \\le x < L$区间内每个点的$T(x)$值不同。在这种情况下，考虑精确解被兼容的近似所取代。\n<br>为了说明上述过程，我们将区间$[0, 1]$分为两个等长的段，并在每个段的两个端点放置一个节点。因此，三个节点定义了整个杆的温度场，即节点$1$位于$x = x_1 = 0$，节点$2$位于$x = x_2 = L/2$，节点$3$位于$x = x_3 = L$，如图1所示。\n<br><center>![图1 区间离散化](1.png)</center>\n\n如果我们假设在节点之间的$\\phi(x)$在每个单元节点$e_i$之间的变化为线性，我们可以使用下述形式表示$T(x)$:\n$$T(x)=\\phi_{i}(x)a_i+\\phi_{i+1}a_{i+1},x_i\\le x\\le x_{i+1}\\tag{1.17}$$\n如确定形状函数$\\phi_i$，使得$\\phi(x_i)=0$且$\\phi(x_{i+1})=0$，相反地$\\phi_{i+1}(x_i)=0$，$\\phi_{i+1}(x_{i+1})=1$，函数$\\phi_i$由下式给出：\n$$\\phi_i(x)=\\frac{x_{i+1}-x}{x_{i+1}-x_i}\\tag{1.18a}$$\n$$\\phi_{i+1}(x)=\\frac{x-x_i}{x_{i+1}-x_i}\\tag{1.18b}$$\n参数$a_i$为节点温度，即$a_i=T(x_i)=T_i$，形状函数的导数为\n$$\\frac{d\\phi_i}{dx}=-\\frac{1}{x_{i+1}-x_i}\\tag{1.19a}$$\n$$\\frac{d\\phi_{i+1}}{dx}=\\frac{1}{x_{i+1}-x_i}\\tag{1.19b}$$\n<br><center>![图2 一个单元上的形状函数](2.png)</center>\n\n方程（1.17）~（1.19）可以使用矩阵形式表述为\n$$T(x)=\\phi \\boldsymbol{a}\\tag{1.20}$$\n式中\n$$\\phi=\\begin{matrix}\n[\\phi_i &\\phi_{i+1}]\n\\end{matrix}\\tag{1.21}$$\n由此得到\n$$\\frac{dT}{dx}=\\frac{d}{dx}\\phi\\boldsymbol{a}=\n\\begin{matrix}\n\\Big[\\frac{d\\phi_i}{dx}&\\frac{d\\phi_{i+1}}{dx}\\Big]\n\\end{matrix}\n\\Big[\n\\begin{matrix}\na_i\\\\a_{i+1}\n\\end{matrix}\n\\Big]\\tag{1.22}$$\n其中\n$$\\frac{d}{dx}\\phi=\\Big[\n\\begin{matrix}\n-\\frac{1}{x_{i+1}-x_i}&\\frac{1}{x_{i+1}-x_i}\n\\end{matrix}\n\\Big]\\tag{1.23}$$\n现在可将以上方程带入到方程（1.16）中，得到\n$$\\sum^2_{j=1}K\\Big[\\int^{L/2}_0\\frac{d\\phi_1}{dx}\\frac{d\\phi_j}{dx}dx\\Big]a_j-\\int^{L/2}_0\\phi_1(x)Qdx-K\\phi_1(x)\\frac{dT}{dx}\\Big|^{x=L/2}_{x=0}=0\\\\ \\tag{1.24a}$$\n和\n$$\\sum^2_{j=1}K\\Big[\\int^{L/2}_0\\frac{d\\phi_2}{dx}\\frac{d\\phi_j}{dx}dx\\Big]a_j-\\int^{L/2}_0\\phi_2(x)Qdx-K\\phi_2(x)\\frac{dT}{dx}\\Big|^{x=L/2}_{x=0}=0\\\\ \\tag{1.24b}$$\n上式使用方程（1.20）~（1.23）表述为\n$$K\\Bigg[\\int^{L/2}_0\\Big[\\frac{d}{dx}\\phi\\Big]^T\\Big[\\frac{d}{dx}\\phi\\Big]dx\\Bigg]\\boldsymbol{a}-Q\\int^{L/2}_0\\phi^Tdx-\\Bigg[\n\\begin{matrix}\nq\\\\0\n\\end{matrix}\n\\Bigg]=0\\tag{1.25}$$\n代入\n$$\\phi=\\Big[\n  \\begin{matrix}\n  1-\\frac{2x}{L}&\\frac{2x}{L}\n  \\end{matrix}\n  \\Big]$$\n和\n$$\\frac{d}{dx}\\phi=\\Big[\n  \\begin{matrix}\n  -\\frac{2}{L}&\\frac{2}{L}\n  \\end{matrix}\n  \\Big]$$\n并积分，得到\n$$\\frac{2K}{L}\\Big[\n  \\begin{matrix}\n    1&-1\\\\\n    -1&1\\\\\n  \\end{matrix}\n  \\Big]\n  \\Big[\n    \\begin{matrix}\n      a_1\\\\\n      a_2\n    \\end{matrix}\n  \\Big]-\\frac{QL}{4}\n  \\Big[\n  \\begin{matrix}\n    1\\\\1\n  \\end{matrix}  \n  \\Big]-\n  \\Big[\\begin{matrix}\n    q\\\\0\n  \\end{matrix}\n  \\Big]=\\Big[\\begin{matrix}\n    0\\\\0\n  \\end{matrix}\n  \\Big]\\tag{1.26}$$\n单元$2$使用相似的方法计算得到\n$$\\frac{2K}{L}\\Big[\n  \\begin{matrix}\n    1&-1\\\\\n    -1&1\\\\\n  \\end{matrix}\n  \\Big]\n  \\Big[\n    \\begin{matrix}\n      a_2\\\\\n      a_3\n    \\end{matrix}\n  \\Big]-\\frac{QL}{4}\n  \\Big[\n  \\begin{matrix}\n    1\\\\1\n  \\end{matrix}  \n  \\Big]-\n  \\Big[\\begin{matrix}\n    q\\\\0\n  \\end{matrix}\n  \\Big]=\\Big[\\begin{matrix}\n    0\\\\0\n  \\end{matrix}\n  \\Big]\\tag{1.27}$$\n  表达式（1.26）和（1.27）通过“组装”，即将方程（1.26）中的第二个方程和方程（1.27）中的第一个方程相加，因为它们都对应于相同的权重函数$\\phi_2(x)$，于是得到\n  $$\\frac{2K}{L}\\Bigg[\n    \\begin{matrix}\n      1&-1&0\\\\\n      -1&2&-1\\\\\n      0&-1&1\n    \\end{matrix}\n    \\Bigg]\n    \\Bigg[\n    \\begin{matrix}\n      a_1\\\\\n      a_2\\\\\n      a_3\n    \\end{matrix}\n    \\Bigg]=\n    \\Bigg[\n    \\begin{matrix}\n      q\\\\\n      0\\\\\n      0\n    \\end{matrix}\n    \\Bigg]+\\frac{QL}{4}\n    \\Bigg[\n    \\begin{matrix}\n      1\\\\\n      2\\\\\n      1\n    \\end{matrix}\n    \\Bigg]\\tag{1.28}\n  $$\n由于已知$a_3=T_L$，上述公式简化为关于未知数$a_1$和$a_2$，即\n$$a_1-a_2=\\frac{ql}{2K}+\\frac{QL^2}{8K}\\tag{1.29a}$$\n$$-a_1+2a_2=\\frac{QL^2}{4K}+T_L\\tag{1.29b}$$\n解为\n$$a_1=\\frac{qL}{K}+\\frac{QL^2}{2K}+T_L,\\\\\na_2=\\frac{qL}{2K}+\\frac{3QL^2}{8K}+T_L,\\\\\na_3=T_L\\tag{1.30}$$\n\n## 1.3 小结\n有限元方法的基本原理在于加权残差法。最常用的两种程序是***Rayleigh-Ritz方法***和***伽辽金方法***。Rayleigh-Ritz方法基于变分计算；然而，这种方法不能用于一些更复杂的方程。伽辽金方法简单易用，即使Rayleigh-Ritz方法无法应用，也能保证得到与主导微分方程兼容的近似解。\n在这两种方法中，依赖变量通过一个有限系列近似表示，其中假设解的“形状”已知，并且取决于有限数量需要确定的参数。将伽辽金近似代入主导微分方程，产生的残差函数与权重函数相乘，要求在积分意义上与权重函数正交，即\n$$\\int W(x)R(T,x)dx=0$$\n其中$R(T, x)$是残差函数（当将近似精确解$T^*$代入微分方程时得到的函数），$W(x)$是权重函数。从这些表达式中生成的一组线性代数方程允许我们确定未知参数，从而得到解的近似值。通过使用积分换元法降低二阶导数项，我们得到了“弱形式”公式。应用弱形式公式产生了一个通用的算法，可扩展到广泛的问题类别。","categories":["FEM"]},{"title":"02-有限元初步（二）（翻译）","url":"/2024/08/31/有限元初步（二）/","content":"# 摘译-使用有限元方法求解泊松方程（二）\n本内容翻译自《Plasma Simulations by Example》(Lubos Brieda，2019），用于在三维空间内求解泊松方程。本部分基于前一篇文章内容，对有限元代码进行解析。\n\n## 1 初始化\n构造函数定义：\n\n\tFESolver::FESolver(World &world, int max_it, double tol):\n\t\tworld{world}, vm{world.vm},\tmax_solver_it(max_it), tolerance(tol)\n    {\n\t    /*count number of unknowns*/\n\t    neq = 0;\n    \t/*OPEN nodes are \"h\" nodes*/\n\t    for (size_t i=0;i<vm.nodes.size();i++)\n\t\t    if (vm.nodes[i].type==NORMAL ||vm.nodes[i].type==OPEN) \n                neq++;\n\t\tcout<<\"There are \"<<neq<<\" unknowns\"<<endl;\n\t\t/*allocate neq*neq K matrix*/\n\t\tK = new double*[neq];\n\t\tfor (int i=0;i<neq;i++) \n\t\t\tK[i] = new double[neq];\n\t\tcout<<\"Allocated \"<<neq<<\"x\"<<neq<<\" stiffness matrix\"<<endl;\n\n\t\t/*allocate neq*neq J matrix*/\n\t\tJ = new double*[neq];\n\t\tfor (int i=0;i<neq;i++) \n\t\t\tJ[i] = new double[neq];\n\t\tcout<<\"Allocated \"<<neq<<\"x\"<<neq<<\" Jacobian matrix\"<<endl;\n\n\t\t/*allocate F0 and F1 vectors*/\n\t\tF0.reserve(neq);\n\t\tF1.reserve(neq);\n\t\tcout<<\"Allocated two \"<<neq<<\"x1 force vectors\"<<endl;\n\n\t\tn_nodes = vm.nodes.size();\n\t\tn_elements = vm.tets.size();\n\n\t\t/*allocate ID vector*/\n\t\tID.reserve(n_nodes);\n\t\tcout<<\"Allocated \"<<n_nodes<<\"x1 ID vector\"<<endl;\n\n\t\t/*allocate location matrix, n_elements*4 */\n\t\tLM = new int*[n_elements];\n\t\tfor (int e=0;e<n_elements;e++) \n\t\t\tLM[e] = new int[4];\n\t\tcout<<\"Allocated \"<<n_elements<<\"x4 location matrix\"<<endl;\n\n\t\t/*allocate NX matrix*/\n\t\tNX = new double**[n_elements];\n\t\tfor (int e=0;e<n_elements;e++) \n\t\t{\t\n\t\t\tNX[e] = new double*[4];\n\t\t\tfor (int a=0;a<4;a++) \n\t\t\tNX[e][a] = new double[3];\n\t\t}\n\t\tcout<<\"Allocated \"<<n_elements<<\"x4x3 NX matrix\"<<endl;\n\n\t\t/*solution array*/\n\t\td.reserve(neq); \t/*initialized to zero*/\n\n\t\t/*allocate memory for g and uh arrays*/\n\t\tg.reserve(n_nodes);\n\t\tuh.reserve(n_nodes);\n\t\tcout<<\"Allocated \"<<n_nodes<<\"x1 g and uh vector\"<<endl;\n\t\n\t\tdetJ.reserve(n_elements);\n\t\tcout<<\"Allocated \"<<n_elements<<\"x1 detJ vector\"<<endl;\n\n\t\t/*electric field*/\n\t\tef.reserve(n_elements);\n\n\t\t/*set up the ID array note valid values are 0 to neq-1 and -1 indicates \"g\" node*/\n\t\tint P=0;\n\t\tfor (int n=0;n<n_nodes;n++)\n\t\t\tif (vm.nodes[n].type==NORMAL ||\n\t\t\t\tvm.nodes[n].type==OPEN) {ID[n]=P;P++;}\n\t\t\telse ID[n]=-1;\t/*dirichlet node*/\n\n\t\t/*now set up the LM matrix*/\n\t\tfor (int e=0;e<n_elements;e++)\n\t\t\tfor (int a=0;a<4;a++)\t/*tetrahedra*/\n\t\t\t\tLM[e][a] = ID[vm.tets[e].con[a]];\n\t\tcout<<\"Built ID and LM matrix\"<<endl;\n\t\n\t\t/*set quadrature points*/\n\t\tl[0]=-sqrt(1.0/3.0); l[1]=sqrt(1.0/3.0);\n\t\tW[0]=1; W[1]=1;\n\t\tn_int = 2;\n\n\t\t/*initialize solver \"g\" array*/\n\t\tfor (int n=0;n<n_nodes;n++)\n\t\t{\n\t\t\tif (vm.nodes[n].type == INLET) g[n]=0;\t/*phi_inlet*/\n\t\t\telse if (vm.nodes[n].type == SPHERE) g[n]=-100; /*phi_sphere*/\n\t\t\telse g[n] = 0;\t/*default*/\n\t\t}\n\n\t\t/*compute NX matrix*/\n\t\tcomputeNX();\n\n\t\t/*sample assembly code*/\n\t\tstartAssembly();\n\t\tpreAssembly();\t/*this will form K and F0*/\n\t}\n\n    ","categories":["FEM"]},{"title":"01-有限元初步（一）（翻译）","url":"/2024/07/30/有限元初步（一）/","content":"# 摘译-使用有限元方法求解泊松方程（一）\n本内容翻译自《Plasma Simulations by Example》(Lubos Brieda，2019），用于在三维空间内求解泊松方程。\n\n## 1 强形式\n泊松方程可以写为\n$$\\nabla^2u\\equiv\\frac{\\partial^2u}{\\partial x^2}+\\frac{\\partial^2u}{\\partial y^2}+\\frac{\\partial^2u}{\\partial z^2}\\equiv u_{,ii}=f\\tag{1.1}$$\n\n在强形式中，我们通常将方程和边界条件写成积分形式，其中下标跟在逗号后面的表示导数，重复的下标意味着求和。这种记号方法被称为指标记号或爱因斯坦记号。我们感兴趣的是在某个空间域$\\Omega$上求解这个方程。为了获得唯一解，我们还需要指定边界条件。我们假设我们知道在边界的一个子集$\\Gamma_g$上的解。即满足**狄利克雷边界条件**。我们还假设在另一个子集$\\Gamma_h$上我们知道解的导数,即满足**纽曼边界条件**。因此，按照爱因斯坦标记法，上述强形式表述为：\n<br>给定$f$：$\\Omega\\rightarrow R$，$g:\\Gamma_g\\rightarrow R$，且$h:\\Gamma_h\\rightarrow R$，寻找$u:\\Omega\\rightarrow R$使得$-ku_{,ii}=f(\\Omega)$,$u=g(\\Gamma_g)$\n\n<br>针对泊松方程求解问题，$u=\\phi，k=1$且$f=\\rho/\\epsilon_0$。需要注意的是，$\\Gamma_g\\notin\\emptyset$，但是$\\Gamma_h$可以是一个空集。狄利克雷边界条件是获得唯一解所必须的边界条件，但是纽曼边界条件可选。两类边界条件不需要连续，我们可以拥有多个非连续的$\\Gamma_g$和$\\Gamma_h$区域。\n\n## 2 弱形式\n弱形式使用两种函数定义解：\n\n* 试解\n* 权重函数（变量）\n<br>解需要满足边界条件，即在$\\Gamma_g$上$u=g$。同时要求解的导数平方可积：\n<br>$$\\int_\\Omega(u_{,i})^2d\\Omega<\\infty\\tag{2.1}$$\n<br>满足上述条件的函数称作$H^1$函数，因此$u\\in H^1$。试解的集合由下式给出：$S=\\{u|u\\in H^1,u=g | \\Gamma_g\\}$\n<br>权重函数与解相似，不同的是他们只满足$g$边界条件的齐次形式：\n$V=\\{w|w\\in H^1,w=0|\\Gamma_g\\}$\n<br>于是弱形式由下述形式给出：\n<br>给定$f:\\Omega\\rightarrow R, g:\\Gamma_g\\rightarrow R, h:\\Gamma_h\\rightarrow R, 找到u\\in S,使得对所有的w\\in V,满足\\int_\\Omega w_{,i}(ku_{,i})d\\Omega=\\int_\\Omega wfd\\Omega+\\int_{\\Omega_h}whd\\Gamma$\n\n<br>与强形式不同，弱形式通过$u$的导数来定义解。这两个解是相同的，如果$u$是$(S)$的解，那么它也是$(W)$的解，如果$u$是$(W)$的解，那么它也是$(S)$的解。我们现在定义几个新的算子以简化记号:\n$$a(w,u)=\\int_\\Omega w_{,i}ku_{,i}d\\Omega\\tag{2.2}$$\n$$(w,f)=\\int_\\Omega wfd\\Omega\\tag{2.3}$$\n$$(w,f)=\\int_{\\Omega_h}wfd\\Omega\\tag{2.4}$$\n\n## 3 伽辽金形式\n接下来在离散化域$\\Omega_h$上近似弱形式。第一步是构建$S$和$V$的有限维近似。代替连续函数，我们现在有了子集$S^h$和$V^h$，其中$S^h\\in S$，$V^h\\in V$。下标$h$表示与网格相关联的属性。因此，如果$u^h\\in S^h$，则$u^h\\in S$。边界条件也成立，即$u^h = g$在$\\Gamma_g$上成立。同样，$V^h$的所有成员在$\\Gamma_g$上消失。然后，我们可以让$S^h$的每个成员由下式表述：\n$$u^h=v^h+g^h\\tag{3.1}$$\n式中$v^h\\in V^h$，$g^h$为在$\\Gamma_g$上满足$u=g$的集合，于是有了伽辽金形式的描述。\n>给定$f$，$g$和$h$，寻找$u^h=v^h+g^h\\in S^h$，使得对于所有的$w^h\\in V^h$，$a(w^h,v^h)=(w^h,f)+(w^h,h)_\\Gamma-a(w^h,g^h)$\n\n## 4 形函数\n假设我们的域由$\\eta = \\{0, 1, …, n_{np−1}\\}$个节点组成。在这些节点中，狄利克雷$g$边界条件被指定的节点由$\\eta_g$给出。那么，$\\eta - \\eta_g$就是解$u^h$需要被确定的节点子集。接下来，我们让$V^h$的成员采取以下形式：\n$$w^h(\\vec{x})=\\sum_{A\\in\\eta-\\eta_g}N_A(\\vec{x})c_A\\tag{4.1}$$\n$$v^h(\\vec{x})=\\sum_{A\\in\\eta-\\eta_g}N_A(\\vec{x})d_A\\tag{4.2}$$\n式中$d_A$为要求解的未知变量。$g$的节点值使用形函数插值得到：\n$$g^h(\\vec{x})=\\sum_{A\\in\\eta_g}N_A(\\vec{x})g_A,g_A=g(\\vec{x_A})\\tag{4.3}$$\n将这些插值函数代入到伽辽金表达式中，得到\n$$\\sum_{B\\in\\eta-\\eta_g}a(N_A,N_B)d_B=(N_A,f)+(N_A,h)_\\Gamma-\\sum_{B\\in\\eta_g}a(N_A,N_B)g_B,$$\n$$A\\in\\eta-\\eta_g\\tag{4.4}$$\n\n## 5 矩阵形式\n定义$K_{AB}=a(N_A,N_B)$，$F_A=(N_A,f)+(N_A,h)_\\Gamma-\\sum_{B\\in\\eta_g}a(N_A,N_B)g_B,A\\in\\eta-\\eta_g$，则式（4.4）变为\n$$\\sum_{B\\in\\eta-\\eta_g}K_{AB}d_B=F_A\\tag{5.1}$$\n进一步使用矩阵形式表述为\n$$\\boldsymbol{K}=[K_{AB}]=\n\\left[\n  \\begin{matrix}\n  K_{0,0}&K_{0,1}&...&K_{0,n-1}\\\\\n  K_{1,0}&K_{1,1}&...&K_{1,n-1}\\\\\n  ...&...&...&...\\\\\n  K_{n-1,0}&K_{n-1,1}&...&K_{n-1,n-1}\n  \\end{matrix}\n  \\right]\\tag{5.2}$$\n$$\\vec{F}=\\{F_A\\}=\n\\left\\{\n  \\begin{matrix}\n  F_0\\\\\n  F_1\\\\\n  ...\\\\\n  F_{n-1}\n  \\end{matrix}\n  \\right\\}\\tag{5.3}$$\n$$\\vec{d}=\\{d_B\\}=\n\\left\\{\n  \\begin{matrix}\n  d_0\\\\\n  d_1\\\\\n  ...\\\\\n  d_{n-1}\n  \\end{matrix}\n  \\right\\}\n$$\n上述矩阵形式表述为\n$$\\boldsymbol{K}\\vec{d}=\\vec{F}\\tag{5.4}$$\n式中$K$为***刚度矩阵***，$\\vec{F}$为受力项，$\\vec{d}$为位移矢量。矩阵形式表述为\n<br>给定系数矩阵$\\boldsymbol{K}$和向量$\\vec{F}$，寻找$\\vec{d}$满足$\\boldsymbol{K}\\vec{d}=\\vec{F}$,其中$\\boldsymbol{K}=[K_{PQ}]$，$\\vec{d}=\\{d_q\\}$，$\\vec{F}=\\{F_p\\}$，$0\\le P,Q<n_{eq}，K_{PQ}=a(N_A,N_B)，P=ID(A),Q=ID(B)，F_P=(N_A,f)+(N_A,h)_\\Gamma-\\sum_{B\\in\\eta_{eq}}a(N_A,N_B)G_B$\n\n需要注意的是，我们只对未知节点$n_{eq}=n_{np}-n_g$应用上述等式，我们需要找到节点标号与未知方程标号的对应关系，我们根据Hughes标记法将其称为ID：\n$$ID(A)=\n\\begin{cases}\nP&A\\in\\eta-\\eta_g\\\\\n0&A\\in\\eta_g\n\\end{cases}\n\\tag{5.5}$$\n\n## 6 单元视角\n上述表述使用了全局视角来表述矩阵问题。在这个视角中，空间位置和插值函数NA在物理$\\vec{x}$坐标中给出。这种表述方式并不实用，因此我们改为使用单元视角。我们让每个元素覆盖一些逻辑域，其坐标为$\\vec{\\xi} = \\{\\xi,\\eta,\\zeta\\}$。现在，插值函数$N_{0,1},…$以这些逻辑或自然坐标表示。整个域的积分现在可以重写为对所有单元的求和。\n$$\\boldsymbol{K}=\\sum^{n_{el}-1}_{e=0}\\boldsymbol{K}^e,\\boldsymbol{K}^e=[K^e_{AB}]\\tag{6.1}$$\n$$\\vec{F}=\\sum^{n_{el}-1}_{e=0}\\vec{F}_e,\\vec{F}_e=\\{F^e_A\\}\\tag{6.2}$$\n其中\n$$K^e_{AB}=a(N_A,N_B)^b=\\int_{\\Omega^e}\\nabla N_A k\\nabla N_B d\\Omega\\tag{6.3}$$\n$$F^e_p=(N_A,f)^e+(N_A,h)^e_\\Gamma-\\sum_{B\\in\\eta_g}a(N_A,N_B)^eg_B\\\\\n=\\int_{\\Omega^e}N_Afd\\Omega+\\int_{\\Gamma^e_h}N_Ahd\\Gamma-\\sum_{B\\in\\eta_g}a(N_A,N_B)^eg_B\\tag{6.4}$$\n在有限元方法中，矩阵方程的单元表述涉及到刚度矩阵的各个元素。这些元素由$a(N_A, N_B)^e$表示，其中$N_A$和$N_B$是插值函数，$e$表示元素编号。刚度矩阵的这些元素代表了该元素内部及其与相邻元素连接处的力与位移的关系。$\\Gamma^e_h$是元素$e$在边界$\\Gamma_h$上的部分，这个边界仅对于位于域边界的元素非空。此外，$P$和$Q$分别是刚度矩阵A和载荷向量B的单元编号映射，即$P = ID(A)$和$Q = ID(B)$。这里的ID表示节点编号与未知方程编号之间的映射表。\n<br>通过计算每个元素在刚度矩阵中的贡献，并将这些贡献加在一起，我们可以得到整个域的刚度矩阵。这个过程涉及到对每个元素内部及其与相邻元素的交界面进行积分。这种方法使得我们可以有效地处理复杂的几何形状和边界条件，同时确保解在指定的边界上满足给定的条件。\n<br>对单个单元重写上述公式为\n$$k^e=[k^e_{ab}],f^e=\\{f^e_a\\},0\\le a,b<n_{en}\\tag{6.5} $$\n$$k^e_{ab}=a(N_a,N_b)^e=\\int_{\\Omega^e}N_afd\\Omega+\\int_{\\Omega^e}N_ahd\\Gamma-\\sum^{n_{en}}_{b=1}k^e_{ab}q^e_b\\tag{6.6}$$\n\n## 7 正交\n假设存在一个从物理坐标到自然（或逻辑）坐标$\\vec{\\eta}=(\\xi,\\eta,\\zeta)$的映射，使得：\n$$x(\\vec{\\eta})=\\sum^4_{a=1}N_a(\\vec{\\xi})\\vec{x}^e_a\\tag{7.1}$$\n式中$\\vec{x}^e_a$是组成单元$e$的四个节点的位置，且$\\xi，\\eta，\\zeta\\in[-1:1]$。这个公式描述了物理坐标可以作为逻辑坐标的函数，可用于对节点位置的插值计算。接下来将积分转换为$\\vec{\\xi}$空间下的积分：\n$$\\int_{\\Omega^e}f(\\vec{x})dxdydz=\\int^1_{-1}\\int^1_{-1}\\int^1_{-1}f(x(\\vec{\\xi}),y(\\vec{\\xi}),z(\\vec{\\xi}))j(\\vec{\\xi})d\\xi d\\eta d\\zeta\\tag{7.2}$$\n式中$j(\\vec{\\xi})=\\partial x_i/\\partial\\xi_i$称为***雅可比矩阵***。\n\n## 8 形状函数及坐标转换\n下面求解\n$$k^e_{ab}=a(N_a,N_b)^e=\\int_{\\Omega^e}N_{a,i}kN_{b,i}d\\Omega\\tag{8.1}$$\n我们可以在逻辑坐标空间$\\vec{\\xi}$中计算。使用链式法则，\n$$\\frac{\\partial N_a}{\\partial x}=\\frac{\\partial N_a}{\\partial\\xi}\\frac{\\partial\\xi}{\\partial x}+\\frac{\\partial N_a}{\\partial\\eta}\\frac{\\partial\\eta}{\\partial x}\\tag{8.2}$$\n或使用爱因斯坦标记法表示为\n$$N_{a,x}=N_{a,\\xi}\\xi_{,x}+N_{a,\\eta}\\eta_{,x}\\tag{8.3}$$\n相似地，\n$$N_{a,y}=N_{a,\\xi}\\xi_{,y}+N_{a,\\eta}\\eta_{,y}\\tag{8.4}$$\n从上式可以得到，我们需要获得$N_a$在逻辑空间中的形函数，$N_a=N_a(\\xi)$。我们也需要映射$\\vec{\\xi}_{,\\vec{x}}$的表达式，于是有\n$$\\int\\Omega f(\\vec{x})d\\Omega=\\int_\\xi f(\\vec{\\xi})|\\vec{x}_{,\\vec{\\xi}}|d\\vec{\\xi}\\tag{8.5}$$\n将式（8.4）和式（8.5）重写为矩阵形式\n$$\\left\\{\n  \\begin{matrix}\n  N_{a,x}\\\\\n  N_{a,y}\n  \\end{matrix}\n  \\right\\}=\n  \\left\\{\n  \\begin{matrix}\n  N_{a,\\xi}\\\\\n  N_{a,\\eta}\n  \\end{matrix}\n  \\right\\}\n  \\left[\n  \\begin{matrix}\n  \\xi_x&\\xi_y\\\\\n  \\eta_x&\\eta_y\n  \\end{matrix}\n  \\right]\\tag{8.6}\n  $$\n  根据$x(\\xi,\\eta)=\\sum^2_{a=0}N_a(\\xi,\\eta)x^e_a，y(\\xi,\\eta)=\\sum^2_{a=0}N_a(\\xi,\\eta)y^e_a$，计算得到\n  $$\\vec{x}_{,\\vec{\\xi}}=\n    \\left[\n  \\begin{matrix}\n  x_{,\\xi}&x_{,\\eta}\\\\\n  y_{,\\xi}&y_{,\\eta}\n  \\end{matrix}\n  \\right]\\tag{8.6}\n  $$\n  而$\\vec{\\xi_{,\\vec{x}}}=(\\vec{x}_{,\\xi})^{-1}$。\n<br>根据以上内容，计算任意单元内$N_{a,x}$和$N_{b,x}$的步骤如下：\n<br>1.计算正交点$l_{\\xi}$处的$N_{a,\\xi}$；\n<br>2.使用$N_{a,\\xi}$计算$\\vec{x}_{,\\vec{\\xi}}$;\n<br>3.计算$\\vec{\\xi_{,\\vec{x}}}=(\\vec{x}_{,\\xi})^{-1}$；\n<br>4.使用$N_{a,\\xi}\\xi_{,x}$计算$N_{a,x}$\n<br>5.对b重复1-4。","categories":["FEM"]}]